# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/178WYMZ7UOHx3We17wqhxEpenbsVzcPuQ
"""

!pip install yfinance filterpy --quiet

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from filterpy.kalman import KalmanFilter
import yfinance as yf

def fetch_intraday_data(ticker="AAPL", interval="5m", period="5d"):
    df = yf.download(ticker, interval=interval, period=period)
    df = df[['Close']].dropna()
    return df

df = fetch_intraday_data()
df.head()

from filterpy.kalman import KalmanFilter
import numpy as np

def apply_kalman_filter(prices):
    """
    Applies a 1D Kalman Filter to denoise a price series.

    Args:
        prices (pd.Series): Time series of prices.

    Returns:
        np.ndarray: Kalman filtered prices.
    """
    kf = KalmanFilter(dim_x=2, dim_z=1)
    initial_price = float(prices.iloc[0])
    kf.x = np.array([[initial_price], [0.]])  # initial state: [price, velocity]

    # System dynamics
    kf.F = np.array([[1., 1.], [0., 1.]])     # State transition matrix
    kf.H = np.array([[1., 0.]])               # Measurement function

    # Covariance and noise settings
    kf.P *= 1.0                               # Initial state covariance
    kf.R = 0.04                               # Measurement noise (adjustable)
    kf.Q = np.array([[1e-6, 0.], [0., 1e-6]]) # Process noise (adjustable)

    # Run the filter
    filtered = []
    for price in prices.values:  # Iterate over the values
        kf.predict()
        kf.update(float(price))
        filtered.append(kf.x[0, 0])
    return np.array(filtered)

df['kf'] = apply_kalman_filter(df['Close'])
df['ma_10'] = df[('Close', 'AAPL')].rolling(10).mean()
display(df.tail())

plt.figure(figsize=(14,6))
plt.plot(df['Close'], label='Raw Price', alpha=0.5)
plt.plot(df['kf'], label='Kalman Filtered', linewidth=2)
plt.plot(df['ma_10'], label='Moving Average (10)', linestyle='--')
plt.title("Signal Smoothing Comparison")
plt.legend()
plt.grid(True)
plt.show()

def signal_to_noise_ratio_db(signal, smoothed):
    # Align signal and smoothed and drop NaNs that result from the alignment
    aligned_signal, aligned_smoothed = signal.align(smoothed, join='inner', fill_value=np.nan, axis=0)
    aligned_signal = aligned_signal.dropna()
    aligned_smoothed = aligned_smoothed.dropna()

    # Ensure aligned data is not empty before calculating variance
    if aligned_signal.empty or aligned_smoothed.empty:
        return np.nan # Return NaN if no valid data points

    residual = aligned_signal - aligned_smoothed

    # Ensure scalar variance calculation by operating on values and specifying axis
    signal_power = np.var(aligned_smoothed.values)
    noise_power = np.var(residual.values)

    # Handle potential division by zero if noise_power is zero
    if noise_power == 0:
        # If signal_power is also zero, SNR is undefined (NaN or 0 depending on context)
        if signal_power == 0:
            return np.nan
        return np.inf

    # Ensure scalar output from the division and log calculation
    return 10 * np.log10(signal_power / noise_power)



snr_kf = signal_to_noise_ratio_db(df[('Close', 'AAPL')], df['kf'])
snr_ma = signal_to_noise_ratio_db(df[('Close', 'AAPL')], df['ma_10'].dropna())

print(f"SNR (Kalman Filter): {snr_kf:.2f} dB")
print(f"SNR (Moving Average): {snr_ma:.2f} dB")